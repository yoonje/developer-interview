# Database

## Table of Contents
* [DBMS](#dbms)
* [DB를 사용하는 이유](#db를-사용하는-이유)
* [테이블](#테이블)
* [도메인](#도메인)
* [행](#행)
* [열](#열)
* [뷰](#뷰)
* [스키마와 테이블의 차이](#스키마와-테이블의-차이)
* [후보 키](#후보-키)
* [주 키](#주-키)
* [외래 키](#외래-키)
* [트랜잭션](#트랜잭션)
* [트랜잭션](#트랜잭션-병행제어)
* [ACID](#acid)
* [무결성 제약조건](#무결성-제약조건)
* [조인](#조인)
* [시퀀스(오라클)](#시퀀스오라클)
* [트리거](#트리거)
* [SQL](#sql)
* [Commit과 Rollback](#commit과-rollback)
* [SQL Injection](#sql-injection)
* [힌트(Hint)](#힌트hint)
* [Index를 사용하는 이유와 장점 및 단점](#index를-사용하는-이유와-장점-및-단점)
* [Index 자료구조](#index-자료구조)
* [Clustered-Index vs Non-Clustered-Index](#Clustered-Index-vs-Non-Clustered-Index)
* [정규화](#정규화)
* [DB 클러스터링과 리플리케이션의 차이](#db-클러스터링과-리플리케이션의-차이)
* [커넥션 풀](#커넥션-풀)
* [관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이](#관계형-데이터베이스sql와-비관계형-데이터베이스nosql의-차이)
* [Redis와 MongoDB](#redis와-mongodb)
* [Redis의 데이터 휘발을 막기 위한 방법](#redis의-데이터-휘발을-막기-위한-방법)
* [PostgresSQL과 ElasticSearch의 차이점](#postgressql과-elasticsearch의-차이점)
* [[추가] NoSQL(Not Only SQL)](#추가-nosqlnot-only-sql)


## DBMS
* 데이터베이스 관리 시스템(DataBase Management System)
* 응용 프로그램들이 데이터베이스를 공유하며 사용할 수 있는 환경을 제공
* 정의(DB의 사용 용도), 조작(수정, 삭제, 검색), 제어(수정, 접근 권한 부여)

## DB를 사용하는 이유
* 파일 시스템의 문제점을 해결하기 위해 사용
* 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침
* 데이터 중복, 비일관성, 검색 등의 문제 존재 -> 중복 최소화, 보안성, 계속적 변화에 대한 적응
* DB는 `원자적 갱신`, `동시성 제어`, `데이터 보호`, `백업 및 회복` 등의 여러 데이터 관리 기능을 두어 데이터 관리를 편하게 하기 때문에 사용

## 테이블
* 행과 열로 이루어진 데이터의 집합

## 도메인
* 데이터베이스 필드에 채워질 수 있는 값들의 집합

## 행
* 테이블을 구성하는 데이터 셋으로 `튜플`이나 `레코드`라고 불림

## 열
* 테이블을 구성하는 데이터 셋으로 `속성`이라고 불림

## 뷰
* 특정 사용자로부터 특정 속성을 `숨기는` 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용하게 하여 특정 속성을 숨김
* 메모리에 물리적으로 존재하지 않는 가상 테이블

## 스키마와 테이블의 차이
* `스키마는 테이블(릴레이션)의 이름과 속성들의 나열`로 테이블에서의 첫 행 헤더, 데이터의 구조와 구성을 설명
* `테이블은 행과 열로 구성된 데이터 집합`

## 후보 키
* 릴레이션을 구성하는 속성들 중에서 Tuple을 `유일하게 식별`할 수 있는 속성들의 부분 집합

## 주 키
* 후보 키 중에서 선택한 Main Key

## 외래 키
* 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
* 참조되는 릴레이션의 `주 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
* 사용 이유: 테이블을 연결, 중복 방지
  * 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 -> 사람과 물건 구매로 테이블을 분리해 중복 제거

## 트랜잭션
* 데이터베이스의 상태를 변화시킬 때 한 번에 수행되어야하는 하나의 `원자적인 작업의 단위`
* Lock과 유사한 기능을 하지만 Lock은 동일한 자원을 요청할 경우 한 시점에는 하나의 커넥션만 변경하는데에 반해 트랜잭션은 논리적인 작업의 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장

## 트랜잭션-병행제어
* 동시에 여러개의 트랜잭션을 병행 수행할 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 `트랜잭션 간의 상호작용을 제어`하는 것
  * 병행성 : 트랜잭션을 동시에 `인터리빙`하게 실행되는 것
  * 인터리빙 : 트랜잭션이 번갈아가며 조금씩 처리를 수행하는 것
* 목적
  * DB의 공유도 최대화
  * 시스템 활용도 최대화
  * 응답 시간 최소화
  * 단위 시간당 트랜잭션 처리 건수 최대화
  * DB의 일관성 유지
* 병행제어의 필요성
  * 갱신 분실
    * 같은 데이터를 공유하여 갱신할 때 갱신 결과의 일부가 사라짐
  * 모순성
    * 동시에 같은 데이터를 갱신할 때, 데이터의 상호 불일치가 발생
  * 연쇄 복귀
    * 트랜잭션 중 하나에 문제가 생겨 롤백되는 경우, 다른 트랜잭션들도 함께 롤백

* 로킹
  * 하나의 트랜잭션이 사용하는 DB내의 data를 다른 트랜잭션이 접근하지 못하게 하나의 트랜잭션 실행될때는 락을 설정하여 다른 트랜잭션이 접근하지 못하도록 `잠근후 실행, 실행 완료 후 언락`
  * 테이블, 속성, 튜플 단위로 락 설정

* 교착상태(데드락)
  * 락 상태가 오래 유지되어 다른 트랜잭션들이 더 이상 진행하지 못하고 무한정 대기
  * 해결법
    * 공유락 : 사용중인 데이터를 다른 트랜잭션이 읽기 허용, 쓰기 불허용으로 설정
    * 베타락 : 사용중인 데이터를 다른 트랜잭션이 읽기, 쓰기 모두 불허용

* 타임스탬프
  * 병행제어의 또 다른 기법. `각 트랜잭션이 데이터에 접근할 시간을 미리 지정` 그 시간의 순서에 따라 순서대로 데이터에 접근하여 수행. 제한적인 시간이 존재하므로 데드락 발생하지 않음


## ACID
* 데이터의 유효성을 보장하기 위한 트랜잭션의 특징
* `Atomicity(원자성)`: `모든 작업이 반영되거나 모두 롤백되는 특성`입니다.
* `Consistency(일관성)`: 데이터는 `미리 정의된 규칙에서만 수정이 가능한 특성`을 의미합니다.
* `Isolation(고립성)`: A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도를 의미합니다.
* `Durability(영구성)`: 한번 반영(커밋)된 트랜젝션의 내용은 `영원히 적용`되는 특성을 의미합니다.

## 무결성 제약조건
* 개체 무결성: 주키는 null, 중복 값을 가질 수 없음
* 참조 무결성: 외래키는 null이거나 참조 릴레이션의 기본키 값과 동일해야 함

## 조인
* 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법으로 적어도 하나의 칼럼을 서로 공유하고 있어야 함

## 시퀀스(오라클)
* 기본키와 같은 유일한 숫자를 자동으로 생성하는 것
* 캐쉬에 있어 속도 빠름, 중복 방지에 사용

## 트리거
* 자동으로 실행되게 정의한 프로시저
* DML(INSERT, UPDATE, DELETE)에 의한 데이터 상태관리 자동화
* 데이터 무결성 강화, 업무 처리 자동화

## SQL
* DML: 데이터를 조작
  |명령어|설명|
  |:---:|:---|
  |SELECT|DB의 데이터 조회 및 검색|
  |INSERT|데이터 삽입|
  |UPDATE|데이터 수정|
  |DELETE|데이터 삭제|
* DDL: 데이터(구조, 객체)를 정의
  |명령어|설명|
  |:---:|:---|
  |CREATE|DB의 테이블 생성|
  |DROP|테이블 삭제|
  |TRUNCATE|테이블의 데이터 삭제, 테이블 초기화|
  |ALTER|테이블 수정|
  * DROP과 TRUNCATE의 차이
* DCL: 데이터 제어
  |명령어|설명|
  |:---:|:---|
  |GRANT|객체에 대한 권한 부여|
  |REVOKE|객체에 대한 권한 회수|
  |COMMIT|트랜잭션의 결과 반영|
  |ROLLBACK|트랜잭션 취소 및 원상 복구|

## Commit과 Rollback
* Rollback: 트랜잭션의 실행을 취소하였음을 알리는 연산자로 `트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산`

## SQL Injection
* 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법
* view를 활용하여 접근하는 에러를 볼 수 없게 하고 검증 로직을 추가하여 방어해야함
* 입력값 검증, Prepared Statement 사용(쿼리에 대한 컴파일을 먼저 수행하고, 입력값을 나중에 넣는 방식)

## 힌트(Hint)
* SQL을 튜닝하기 위한 지시 구문, 개발자가 직접 최적의 실행 계획을 제공하는 것

## Index를 사용하는 이유와 장점 및 단점
* 인덱스는 추가적인 쓰기와 저장 공간 사용을 통해 데이터베이스의 `검색 속도 향상`을 위해 사용하는 자료구조
* 테이블 내의 `칼럼의 값(Key)`과 해당 `Key의 레코드가 저장된 주소`를 `키와 값의 쌍으로 정의`
* 인덱스를 사용하면 검색이 빨리지지만 테이블의 데이터가 추가, 삭제, 수정이 자주되는 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음

## Index 자료구조
* B 트리

  ![tree](https://user-images.githubusercontent.com/38900338/105454677-9bf88400-5cc5-11eb-993e-fb6f7b9675a1.png)
  * 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 자료구조
  * 균형 트리: 루트 ~ 리프의 거리가 일정한 트리
  * Branch 노드: Key와 Data 저장
* B+ 트리

  ![Bplustree](https://user-images.githubusercontent.com/38900338/105454222-d9104680-5cc4-11eb-96e9-31e46c0bf2aa.png)
  * B 트리를 확장해서, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가시킨 자료구조
  * B 트리보다 풀 스캔 빠름
  * Leaf 노드를 제외하면 데이터를 저장하지 않아 더 많은 Key를 저장할 수 있음 -> 트리의 높이가 낮아져 Cache Hit 향상 가능
  * Branch 노드: Key만 저장, Leaf 노드: Key와 Data 저장 + Linked List로 연결(부등호를 사용한 순차 검색에 유용)
* 해시 테이블
  * 칼럼의 값으로 생성된 해시를 기반으로 인덱스 구현
  * O(1)로 매우 빠름
  * 인덱싱에선 부등호 연산 때문에 해시 테이블을 사용하면 성능이 떨어짐
  * `>=, Between, like, order by` 등은 불가능하지만 `==, in, is null` 등에서의 성능은 좋음

## Clustered-Index vs Non-Clustered-Index
* Non-Clustered Index
  * 물리적으로 재배열 하지 않는다
  * 인덱스 키 값에는 해당 데이터에 대한 포인터가 존재
    * 인덱스의 구조는 데이터 행과 독립적
    * 한 테이블에 여러 개 생성 가능
  * 리프노드에 있는 테이블 번호를 통해 해당 테이블로 가서 찾고자하는 데이터의 주소를 찾아 검색

* Clustered Index
  * 물리적으로 정렬이 되어 있는 상태로 데이터가 저장
  * 데이터를 인덱스로 지정한 컬럼에 맞춰서 정렬
    * 테이블 구조에 영향을 미치는 인덱스
    * 한 테이블에 하나만 생성 가능
  * 클러스터 키로 검색 시 처리 성능이 매우 빠름


## 정규화
* 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 `무손실 분해` 하는 과정
  * 무손실 분해: 하나의 릴레이션을 분해하고 다시 조인연산을 했을 때 데이터 손실이 없는 것
* 데이터 `중복 최소화`, `이상 현상` 제거
* 종류
  * 제 1 정규형: 모든 속성이 원자 값
  * 제 2 정규형: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속(속성집합 Y 가 속성집합 X 전체에 대해서만 함수적으로 종속된 경우)
  * 제 3 정규형: 기본키가 아닌 모든 속성이 기본키에 비이행적 종속(직접 종속)
    * 이행적으로 함수 종속: X, Y, Z 에 대해 X->Y 이고 Y->Z 이면 X->Z
  * BCNF: 함수 종속성 X->Y일 때, 모든 결정자 X가 후보키

## DB 클러스터링과 리플리케이션의 차이
  ||DB 클러스터링|리플리케이션|
  |:---:|:----------:|:---------:|
  |대상|DB 서버를 다중화|DB 서버와 데이터를 같이 다중화|
  |구조|수평적 구조<br>(Fail Over)|수직적 구조<br>(Master-Slave)|
  |방식|동기 방식으로 동기화|비동기 방식으로 동기화|
  |종류|Active - Active, Active - Standby|단순 백업, 부하 분산|
  |장점|일관성,<br>1개의 서버가 고장나도 시스템은 계속 사용 가능|시간 지연 거의 없음|
  |단점|동기화 시간 소요|일관성 없음,<br>Master 오류시 복구 어려움|
  |구조|![clustering](https://user-images.githubusercontent.com/38900338/105463364-4b882300-5cd3-11eb-9837-195b872852e2.JPG)|![replication](https://user-images.githubusercontent.com/38900338/105463420-5f338980-5cd3-11eb-8ea4-fe1bdc962385.JPG)|

## 커넥션 풀
* 사용자의 요청에 따라 Connection 을 생성하다 보면 많은 수의 연결이 발생했을 때 서버에 과부하가 걸리게 되므로 이러한 상황을 방지하기 위해 `미리 일정 수의 Connection을 만들어 pool에 담아 뒀다가 사용자의 요청이 발생하면 연결을 해주고 연결 종료 시 pool에 다시 반환하여 보관하는 것`
* 커넥션 풀을 사용하면 커넥션을 생성하고 닫는 시간이 소모되지 않기 때문에 그만큼 어플리케이션의 실행 속도가 빨라짐
* 한 번에 생성될 수 있는 커넥션 수를 제어하기 때문에 동시 접속자 수가 몰려도 웹 어플리케이션이 쉽게 다운되지 않음

## 관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이
|관계형 데이터베이스|비관계형 데이터베이스|
|:----------:|:---------:|
|SQL 사용|다양한 질의어 사용|
|ACID|Eventual Consistency|
|엄격한 스키마 아래 행과 열로 구성된 `테이블`들의 관계로 데이터 저장|스키마가 없거나 느슨한 스키마로 데이터 저장|
|`속성(열)에 맞는 자료형에 따라` 데이터를 삽입|`key-value`, `Document` 구조의 유연한 데이터 삽입 구조를 갖음|
|관계를 맺고 있는 데이터가 자주 변경되거나 테이블 안에서 읽어올 데이터가 불분명한 경우 또는 명확한 스키마가 있는 경우|데이터 구조를 알 수 없거나 테이블 안에서 읽어올 데이터가 분명한 경우 또는 변경 확장이 쉽게 되어야하는 경우|
|데이터의 정렬, 탐색, 분류가 빠름<br>데이터 무결성 보장|대용량 데이터 처리에 효율적<br>관계형 DB보다 쓰기와 읽기 성능이 좋음<br>유연하고 확장성 좋음|
|기존의 스키마 수정 어려움, 빅데이터 처리에 비효율적|크기가 큰 Document에서는 성능 저하|
|`Oracle`, `MySQL`|키-값: `Redis`<br>문서형(JSON, XML): `MongoDB`|

## Redis와 MongoDB
* Redis는 No SQL 방식을 사용하는 인메모리 데이터베이스로 `Key-Value` 형식으로 데이터를 저장하며 주로 캐쉬로 사용
* MongoDB는 NO SQL 방식을 사용하는 데이터베이스로 JSON같은 구조의 `Document` 형식으로 데이터를 저장하고 문서에 대한 ID를 키로 표현

## Redis의 데이터 휘발을 막기 위한 방법
* `snapshot` 기능을 통해 디스크에 백업하거나 `AOF(Append Only File)` 기능을 통해 `명령 쿼리를 저장`해두고 서버가 셧다운 되면 재실행
* snapshot: 특정 시점의 백업 및 복구에 유리, 빠르게 복구 가능, 서버가 다운되면 스냅샷 사이에 변경된 데이터 유실
* AOF: 모든 write/update 연산 자체를 모두 log 파일로 기록, 서버가 실행되면 순차적으로 연산을 재실행하여 데이터를 복구, write 속도 빠름, 데이터 유실X, 데이터 사용량이 큼, 서버 restart 시 속도 느림

## PostgresSQL과 ElasticSearch의 차이점
* PostgresSQL은 관계형 데이터베이스이고 ElasticSearch는 검색 및 분석엔진
* ES는 데이터 모델을 JSON으로 하고 있어 NoSQL처럼 사용할 수 있음

## [추가] NoSQL(Not Only SQL)
* 관계형 데이터베이스가 아닌 다른 형태로 데이터를 저장하는 기술
* 특징
  * 반정형(명확한 스키마 없음, 일정 수준의 자유도 허용, NoSQL/JSON 형태의 데이터)/비정형(스키마 없음, 비디오/오디오 등의 멀티미디어 데이터) 데이터에 적합
  * ACID 대신 Eventual Consistency: Consistency를 조금 타협하고 꼭 실제 최신은 아닐 수 있지만 `업데이트가 되기 전까지는` 가지고 있는 최신의 데이터를 반환함을 의미 -> 분산형의 특성상 일관성 유지가 어려움
  * 대용량/분산형 데이터 저장에 유리
  * 특정 도메인의 문제 해결에 좋음: Key-value, Graph 등 자료 형태가 다양해 특정 분야에서 고성능(소셜 네트워크: 인간 관계는 그래프)
  * 데이터를 질의하는 API가 다양
  * 분산형 컴퓨터에 최적화, 확장성 좋음: 머신의 수를 늘리는 `수평적 확장`
  * NoSQL은 SQL보다 제품 지원이 어려움
  * 인력 운영 비용이 더 비쌈: 표준화 부족, 질의 언어 다양
* 종류
  * Column-based: 열 별로 연속적으로 저장, 기존 SQL은 테이블에 행 단위로 순차적으로 저장 -> 레코드의 특정 부분만 수정할 때, 필요한 열의 데이터만 로드하면 되서 IO 작업 감소, 한 열에 들어가는 데이터 형식에 일관성이 있어 DB 내의 한 블록은 동일한 유형의 데이터를 보유 -> 데이터의 유형에 맞는 압축 인코딩 가능, 디스크 공간 절약 및 성능 향상 가능
  * Document-oriented: JSON 객체로 문서(레코드)를 구성, 다양항 구조로 테이블 구성 가능, `MongoDB`
  * Key-Value: 연관 배열을 데이터 모델로 이용, Key는 한 Collection에 한 번만 등장 가능
  * Graph