# Network

<br>

## Table of Contents
* [TCP와 UDP의 차이](#tcp와-udp의-차이)
* [TCP 흐름제어](#tcp-흐름제어)
* [TCP 혼잡제어](#tcp-혼잡제어)
* [TCP 3-way Handshake](#tcp-3-way-handshake)
* [TCP 4-way Handshake](#tcp-4-way-handshake)
* [OSI 7계층](#osi-7계층)
* [CDN Contents Delivery Network](#cdn-contents-delivery-network)
* [로드 밸런싱](#로드-밸런싱)
* [CIDR](#cidr)
* [HTTP 특징](#http-특징)
* [HTTP 1, 2, 3의 차이](#http-1-2-3의-차이)
* [HTTP 상태코드](#http-상태코드)
* [HTTP와 HTTPS(HTTP Secure)의 차이](#http와-httpshttp-secure의-차이)
* [SSL(Secure Sockets Layer) 동작방식](#sslsecure-sockets-layer-동작방식)
* [TLS(Transport Layer Security) 동작방식](#tlstransport-layer-security-동작방식) *
* [HSTS(HTTP Strict Transport Security)](#hstshttp-strict-transport-security)
* [쿠키와 세션](#쿠키와-세션)
* [캐시](#캐시)
* [JWT](#jwt)
* [웹 브라우저에 URL을 입력했을 때의 수행 과정](#웹-브라우저에-url을-입력했을-때의-수행-과정)
* [기타 네트워크 프로토콜과 기본 네트워크 주소들](#기타-네트워크-프로토콜과-기본-네트워크-주소들)
* [웹 캐시](#웹-캐시)
* [URI, URL, URN](#uro-url-urn)
* [REST](#rest)
* [REST API](#rest-api)
* [REST API 장단점](#rest-api-장단점)
* [RESTful](#restful)
* [HTTP GET 방식과 POST 방식의 차이](#http-get-방식과-post-방식의-차이)
* [HTTP POST 방식과 PUT 방식의 차이](#http-post-방식과-put-방식의-차이)
* [HTTP 멱등성](#http-멱등성)
* [웹 브라우저에 HTTP 응답이 랜더링되는 과정](#웹-브라우저에-http-응답이-랜더링되는-과정) *

<br>

## TCP와 UDP의 차이
* TCP는 `신뢰성을 보장하는 연결형 프로토콜`로 `흐름제어, 혼잡제어`를 제공
* UDP는 `신뢰성을 보장하지 않는 비연결형 프로토콜`로 흐름제어, 혼잡제어를 제공하지 않음

<br>

## TCP 흐름제어
* 수신자와 송신자의 메시지 처리속도 차이를 해결하기 위한 방법
* 수신자와 송신자 세그먼트 간의 TCP Header에 `remain window data`를 통해 남은 버퍼를 알고 흐름을 파악할 수 있음
### 종류
* `Stop and Wait`: 전송한 패킷의 ACK을 수신하면 다음 패킷 전송
* `Sliding Window`: N개의 패킷을 ACK의 확인 없이 전송, 데이터의 흐름을 동적으로 조절
  * `Go Back N`: Cumulative ACK(마지막으로 수신 성공한 패킷의 ACK을 계속 전송), 문제가 된 패킷부터 모두 재전송
  * `Selective Repeat`: Individual ACK(수신 성공한 패킷의 개별 ACK 전송), 문제가 된 패킷만 재전송

<br>

## TCP 혼잡제어
* 송신자와 네트워크(라우터)의 데이터 처리 속도 차이를 해결하기 위한 방법
* 패킷 loss 시의 확인되는 `timeout이나 3개의 duplicate ACK`을 통해서 파악 가능
### 종류
* [참고] CWND: Congestion Window, ACK을 확인하지 않고도 보낼 수 있는 데이터 양
* `TCP Tahoe`
  * Slow Start(CWND가 1부터 지수적으로, 2배씩 증가) -> ssthresh -> Congestion Avoidance(CWND가 1씩 증가) -> 3개의 duplicate ACK, Timeout 발생 -> Slow Start부터 반복
* `TCP Reno`
  * Slow Start(CWND가 1부터 지수적으로, 2배씩 증가) -> ssthresh -> Congestion Avoidance(CWND가 1씩 증가)까지는 동일
  * Congestion Avoidance 상황에서 3개의 duplicate ACK 발생 -> CWND를 1/2배로 감소하고 선형적 증가
   (TCP Tahoe는 Slow Start로 진입)
  * Congestion Avoidance 상황에서 Timeout 발생 -> Slow Start (CWND = 1, CWND가 1부터 2배씩 증가)

<br>

## TCP 3-way Handshake

```
❔ 언제 일어나고 어떤 과정인지
```

* 서버와 클라이언트가 TCP `연결을 성립할 때` 사용
* Client -> Server: `SYN 전송`
* Server -> Client: `SYN 전송 + ACK 전송`
* Client -> Server: `ACK 전송`
* TCP는 양방향성 연결이기 때문에 발생하는 매커니즘으로 연결을 성립할 때는 서버가 준비가 다 된 상태인 대기 상태에서 시작하여 3-way로 가능
* TCP는 양방향 프로토콜이므로 클라이언트와 서버가 각각 서로에게 패킷을 전송할 수 있다는 것을 확인해야 되므로 3 way 사용

<br>

## TCP 4-way Handshake

```
❔ 언제 일어나고 어떤 과정인지
❔ 타임아웃은 언제, 왜 일어나는가
```

* 서버와 클라이언트가 TCP `연결을 종료할 때` 사용
* Client -> Server : `FIN 전송`
* Server -> Client : `ACK 전송`
* Server -> Client : `FIN 전송`
* Client -> Server : `ACK 전송`
* 서버의 지연된 패킷을 수신하기 위해 클라이언트에 `Timeout` 존재 (클라이언트가 서버의 FIN을 수신한 이후)
* TCP는 양방향성 연결이기 때문에 발생하는 매커니즘으로 연결 해제할 때는 한 쪽이 준비가 되지 않은 상태이기 때문에 연결 해제 대기 상태로 만들기 위해서 4-way로 해야 가능
* 클라이언트가 일방적으로 끊으면 서버는 '연결은 되어 있으나 요청이 없는 상태'로 오해할 수 있어 4 way 사용
* 클라이언트는 데이터 전송을 끝냈다고 하더라도 서버는 전송할 것이 남아있을 수 있어 4 way 사용

<br>

## OSI 7계층
```
❔ OSI 7계층이란
❔ 각 계층의 역할
```

### (1) 정의
* 네트워크의 통신 과정을 7단계로 나눈 것
### (2) 사용 이유
* 이해하기 쉬움, 문제 발생시 해당 단계의 장비와 SW만 수정하면 됨
### (3) 종류
* Application - Application(7), Presentation(6), Session(5) 계층으로 분리
* Application(7, Data): 사용자에게 `실제 애플리케이션 서비스를 제공`하는 계층 / HTTP
* Presentation(6, Data): 애플리케이션의 `데이터 형태와 구조를 변환(번역, 암호화, 압축)`시키는 계층
* Session(5, Data): 애플리케이션 간의 `TCP/IP 세션을 구축하고 관리하며 종료`시키는 계층
* Transport(4, Segment): 통신 `양단 간의 신뢰성 있는 통신`을 보장하는 계층 / TCP or UDP
* Network(3, Packet or Datagram): 목적지까지의 경로를 선택하고 `경로에 따라 패킷을 전달(라우팅)`해주는 계층 / IP
* Link(2, Frame): 인접한 `피어 간의 신뢰성 있는 통신`을 보장하는 계층 / MAC
* Physical(1, Bit): 전기적, 기계적, 기능적인 특성을 이용해서 `통신 케이블로 데이터를 전송`

<br>

## CDN (Contents Delivery Network)
```
❔ CDN이란
❔ 사용 시의 이점
```
![zz](https://user-images.githubusercontent.com/38900338/135851877-de1980d4-c90f-44c9-89d9-91899775feb6.PNG)

### (1) 정의
* `지리적, 물리적으로 떨어져 있는` 사용자에게 웹 페이지 콘텐츠 `로드 지연을 최소화`하는, 촘촘히 `분산된 서버`로 이루어진 플랫폼 기술

### (2) 이점
* 지리적으로 가까운 캐시 서버가 응답하여 빠른 응답 가능
* Origin 서버에 문제가 생겨도 다른 서버로 대체가 가능해 안전성 증가
* 트래픽 집중 방지 가능

### (3) 과정
* 웹 브라우저를 실행하는 디바이스인 사용자 에이전트는 HTML, 이미지, CSS, JavaScript 파일을 렌더링하는데 필요한 콘텐츠를 요청
* 요청된 서버에 의해 `콘텐츠에 대한 각 요청이 발생하면 최적으로 배치된 CDN 서버에 엔드유저가 매핑`
* CDN 서버는 요청된 파일의 `캐싱`된(사전 저장된) 버전으로 응답

<br>

## 로드 밸런싱
* 로드 밸런서를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산하는 방식
* 로드 밸런서는 물리 장비를 이중화해서 구현하거나 nginx(엔진X)와 같은 웹서버를 이용하여 구현

<br>

## CIDR
* 클래스 없는 도메인 간 라우팅 기법
* 최신의 IP 주소 할당 방법으로 정적이였던 클래스 방식에 비해 IP 주소의 영역을 여러 네트워크 영역으로 나눌 수 있기 때문에 기존방식에 비해 유연

<br>

## HTTP 특징
* Connectionless: 클라이언트에서 서버에 요청을 보내면 서버는 클라이언트에 응답을 하고 접속을 끊음
* Stateless: HTTP 통신은 요청을 응답하고 접속을 끊기 때문에 클라이언트의 상태정보를 저장하지 않음

<br>

## HTTP 1, 2, 3의 차이
* HTTP 0.9: HTML파일 자체를 응답으로 보냄. 하나의 연결당 1요청 1응답 -> 성능 저하, 서버 부하
* HTTP 1.0: 헤더가 생김. 하나의 연결당 1요청 1응답 -> 성능 저하, 서버 부하
* HTTP 1.1: 연결 당 하나의 요청과 응답을 처리 -> 동시 전송 문제, 속도 성능 이슈가 있음
  * Persistent Connection: 지정한 timeout 동안 커넥션을 닫지 않는 방식
  * 파이프라이닝: 1->2->3 순서대로 각 번호의 요청에 대한 응답을 받아야 처리가 되서, 응답 시간을 줄이고자 등장
    * 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄이는 방법
  * HOL(Head of Line) Blocking: 파이프라이닝의 문제점 -> 먼저 받은 요청이 끝나지 않으면 그 뒤에 있는 요청도 처리 불가
  * RTT(Round Trip TIme) 증가
  * 헤더가 큼: 쿠키가 큼. 연속적인 데이터일때, 헤더가 동일하더라도 또 보내게됨.
* HTTP 2: `멀티플렉싱`을 통해 레이턴시를 줄이고, `헤더압축`을 통해 오버헤드를 최소화하며, `서버 푸시 기능`을 지원
  * 메시지 전송 방식 변화: 바이너리 프레이밍 계층 사용 -> 파싱,전송 속도 향성, 오류 발생 가능성 저하
    * 메시지: 다수의 프레임. 요청 응답의 단위
    * 스트림: 양방향 통신을 통해 전달되는 한 개 이상의 메시지
    * 프레임이 여러개가 모여 메시지, 메시지가 여러개가 모여 스트림
  * 한 연결에 여러 메시지를 동시에 처리 가능: 요청들이 프레임 단위로 쪼개짐.(헤더, 데이터 등) -> 메시지 전송과 응답에 순서가 중요하지 않아짐 -> `HOL Blocking 해결`
  * 헤더 압축: 헤더 중복 제거 -> 페이지 로드 시간 감소
  * TCP에서 동작, 스트림
  * Server Push: html 요청이 오면, css와 js 파일이 필요할 것을 예상하고 서버에서 자체적으로 클라이언트에게 보냄
  * 리소스간 우선 순위 설정
* HTTP 3(QUIC): 
  * 헤더 압축(QPACK)
  * 전송 계층 프로토콜
  * 현재 구글 관련 제품 대부분의 기본 프로토콜: UDP기반
  * TCP는 신뢰성을 확보하지만 지연을 줄이기 힘듦. UDP는 공간이 많아 TCP의 지연을 줄이면서 TCP만큼 신뢰성을 보장하도록 개발
  * 전송 속도 향상: 첫 연결 설정에서 필요한 정보와 함께 데이터 전송 -> 연결 성공시 설정을 캐싱하여 다음 연결 때 바로 성립 가능
  * Connection UUID: 고유한 식별자로 서버와 연결 -> 커넥션 재수립 필요X
  * 독립 스트림 -> 향상된 멀티플렉싱

<br>

## HTTP 상태코드  
* 2xx: 성공
* 3xx: 리다이렉션
  * 301(Moved Permanently): 요청한 자원의 URL이 변경됨, 새로운 URL이 응답에 있을 수도 있음
  * 302(Found): 요청한 자원의 URL이 일시적으로 변경됨, 새롭게 변경된 URL이 나중에 만들어질 수도 있어 클라이언트는 동일한 URI로 요청해야 함
* 4xx: 클라이언트 에러
  * 401(Unauthorized): 클라이언트는 요청에 대한 응답을 받기위해 인증이 필요
  * 403(Forbidden): 클라이언트는 자원에 접근할 권리가 없음, 401과 다르게 서버가 클라이언트가 누구인지 알 고 있음
* 5xx: 서버 에러

<br>

## HTTP와 HTTPS(HTTP Secure)의 차이
||HTTP|HTTPS|
|:---:|:---:|:---:|
|정의|웹 브라우저와 웹 서버가 통신하기 위한 프로토콜|HTTP에 SSL/TLS 기반의 Secure Socket을 활용한 프로토콜|
|보안|평문 통신이기 때문에 `도청`이 가능하고 `변조`가 가능<br>통신 상대를 특정하지 않기 때문에`위장`이 가능|웹 브라우저와 웹 서버가 각각 키를 가지며<br>`그 키를 통해 암호화/복호화하여 HTTP통신`을 하기 때문에<br>클라이언트와 서버만이 데이터를 열람 가능|

<br>

## 대칭키 암호화
* 하나의 키로 암/복호화를 모두 하는 방식

<br>

## 비대칭키(공개키) 암호화
```
❔ 비대칭키(공개키) 암호화란
```
* 두 개의 키로 암/복호화를 하는 방식
* A, B 키 -> A키로 암호화하고 B키로 복호화 또는 B키로 암호화하고 A키로 복호화
* 비공개키(개인키)는 자신만이 소유하고 공개키는 타인에게 제공하는 방식으로 작동

## 인증기관(Certification Authority, CA)
* 인증기관으로부터 공인인증서를 발급받아 서버에 설치해야 HTTPS 통신 가능
* 웹 서비스 제공자는 자신의 공개키와 개인키를 생성, 공개키를 인증기관에 보냄
* 인증기관은 공개키, 유효기간 등 정보를 포함하여 인증기관의 개인키로 전자서명한 인증서를 발급
* 웹 서버는 인증서와 개인키를 가지게 되어 HTTPS 통신을 할 수 있게 됨
* 클라이언트에는 여러 인증기관의 공개키와 인증서가 이미 설치되어 있음
* 웹 서버와 통신 시, 인증기관의 `개인키`로 서명된 인증서를 클라이언트가 받으면 인증기관의 `공개키`로 복호화 가능

## SSL(Secure Sockets Layer) 동작방식
* SSL을 사용하면 `https://` 를 사용하여 웹서버에 접근
* 대칭키: 실제 데이터 암호화 방식
* 공개키: 대칭키를 공유하기 위해 사용
1. 웹 브라우저가 웹 서버에 접속<br>
2. 웹 서버는 인증서를 웹 브라우저에게 전송 -> 인증서: 인증기관의 개인키로 암호화된 `사이트의 정보`와 `공개키`가 있음<br>
3. 웹 브라우저는 이미 가지고 있는 인증기관의 `공개키`로 웹 서버에서 받은 인증서를 `복호화` 해서 확인<br>
4. 웹 브라우저는 실제 데이터의 암호화에 사용될 `대칭키`를 생성, 인증서에서 꺼낸 웹 서버의 `공개키`로 `암호화` 해서 웹 서버로 전송<br>
5. 웹서버는 자신이 가지고 있는 `개인키`로 웹 브라우저가 보내온 `대칭키`를 `복호화` 해서 얻음<br>
6. 해당 대칭키로 데이터를 암호화해서 주고 받음

## TLS(Transport Layer Security) 동작방식 *

## HSTS(HTTP Strict Transport Security)
*  Web Site에 접속할 때, 강제적으로 `HTTPS Protocol`로만 접속하게 하는 기능
* 일정시간 (max-age) 동안 HSTS 응답을 받은 웹사이트에 대해서 https 접속을 강제화
* 브라우저는 HTTPS를 사용해야 하는 웹 사이트의 목록을 만들고 이것을 사용
### 사용 목적
* SSL Stripping 공격(중간자 공격)을 방지하기 위해 사용
* 사용자가 HTTPS를 지원하는 사이트에 HTTP로 접속 했을 때, 중간자 공격에 의해 HTTP 통신을 하게 되어 공격자에게 정보가 노출되는 것을 방지

## 쿠키와 세션
* HTTP 통신에서 Connectionless, Stateless 보완
### (1) 쿠키
* `클라이언트의 로컬(브라우저)`에 저장되는 `키와 값`이 들어있는 작은 텍스트 데이터 파일
* 이름, 값, 만료 날짜/시간, 경로 정보 등 저장
* 예시: 자동 로그인, 쇼핑몰의 장바구니, 아이디와 비밀번호 저장
### (2) 쿠키의 동작 과정
1. 클라이언트가 서버에 요청<br>
2. 서버는 `HTTP 응답 헤더`에 `set-cookie` 속성을 추가하여 응답 -> 클라이언트는 쿠키 저장<br>
3. 클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청헤더에 추가하여 요청(브라우저가 자동으로 추가)<br>
4. 서버에서 쿠키를 참고하여 로직 수행<br>
### (3) 세션
* 일정 시간동안 같은 브라우저에서 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 객체로 `서버`에 저장하는 기술
* 예시: 로그인
### (4) 세션의 동작 과정
1. 클라이언트가 서버에 요청<br>
2. 서버는 세션에 클라이언트에 대한 데이터를 저장하고 `HTTP 응답 헤더`에 `sessionid`를 추가하여 응답<br>
3. 클라이언트는 이후 서버에 요청할 때 전달받은 세션 쿠키를 자동으로 요청헤더에 추가하여 요청<br>
4. 서버에서 `sessionid`를 참고하여 로직 수행<br>
### (5) 차이점
||쿠키|세션|
|:---:|:---:|:---:|
|저장 위치| 클라이언트 `로컬`에 `작은` 파일로 저장|`서버`에 `제한 없는` 파일로 저장|
|보안|파일로 저장해 탈취와 변조 가능<br> 응답/요청 시에 스니핑 위험이 있음|`sessionid`를 통해 데이터를 구분하여 처리하여 보안이 좋음|
|Life Cycle|브라우저를 종료해도 파일로 남음|브라우저 종료 시, 세션 삭제|
|속도|파일에서 읽어 빠름|요청마다 서버에서 처리해 느림|

## 캐시
* 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것
* 같은 자원을 로드(load)해야할 때, 해당 자원을 다시 불러오지 않고 캐시되어 있는 자원을 써서 클라이언트 자원을 절약
* 캐시에 있는 것을 재사용하기 때문에 경우에 따라 변경된 자원을 참조할 수 없는 경우가 생김

## JWT *
* JSON Web Token
* `Json` 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token
* Header, Payload, Signature로 구성
* 세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에, 최근에는 세션의 문제를 보완한 토큰 기반의 인증방식을 사용하는 추세

## 웹 서버와 웹 애플리케이션 서버의 차이점
* 웹 서버: Http 프로토콜을 기반으로, 클라이언트의 요청을 처리하는 서버로 `정적 컨텐츠`만 처리하는 고성능 서버
* 웹 애플리케이션 서버: 보통 웹서버 뒤에서 DB 조회 및 다양한 로직 처리 요구 시, `동적 컨텐츠`를 처리하는 서버

## 웹 브라우저에 URL을 입력했을 때의 수행 과정
* 사용자의 PC는 `DHCP 서버`에서 사용자 `자신의 IP 주소`, `가장 가까운 라우터의 IP 주소`, `가장 가까운 DNS서버의 IP 주소`를 받는다.
* `ARP`를 이용하여 IP 주소를 기반으로 가장 가까운 라우터의 MAC 주소를 받는다.
* 가장 가까운 라우터의 MAC 주소와 IP 주소를 사용해 DNS 서버로 쿼리를 전송하고 URL의 IP 주소를 응답받는다.
* TCP Socket을 통해 웹 서버와 `3 way hand shaking`을 하여 연결한다.
* `HTTP Request`가 TCP Socket을 통해 보내지고, 응답으로 웹페이지의 정보가 사용자의 PC에 전달

## 기타 네트워크 프로토콜과 기본 네트워크 주소들
* DHCP: 호스트의 IP 주소 및 TCP/IP 설정을 클라이언트에 자동으로 제공하는 프로토콜
* DNS: IP 주소와 도메인의 매핑 정보를 관리하는 프로토콜
* ARP: IP 주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜
* IP 주소: 컴퓨터 마다 부여된 고유의 주소
* MAC 주소: NIC 카드 마다 부여된 네트워크 장비 고유의 주소

## 웹 캐시
* 대부분의 브라우저에서는 `HTTP 헤더`에 캐시 구현이 포함되어 있어서 웹 캐시를 구현
* 응답 헤더의 `Last-Modified`, Etag, Expires, Cache-Control 항목 등과 같은 여러 부분의 여러 개의 태그를 통해서 캐싱
* `Cache-Control`: HTTP 헤더를 통해 캐싱 정책을 정의할 수 있다. `no-cache` vs `no-store`
* 브라우저는 최초 응답 시 받은 `Last-Modified` 값을 If-Modified-Since라는 헤더에 포함 시켜 페이지를 요청 ->서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면200 OK -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은 후 Last-Modified값을 갱신
* 브라우저는 최초 응답 시 받은 `Etag` 값을 If-None-Match라는 헤더에 포함 시켜 페이지를 요청 -> 서버는 요청 파일의 Etag 값을 If-None-Match 값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag값을 응답 헤더에 전송 -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은 후 Etag값을 갱신
* 브라우저는 최초 응답 시 받은 `Expires` 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드

## URI, URL, URN
### (1) URI(Uniform Resource Identifier)
* 자원을 고유하게 식별하고 위치를 지정하는 통합 자원 식별자
* URL, URN 두 가지 형태 존재
* 인터넷 프로토콜을 명시함
* 예시: http://www.naver.com
### (2) URL(Uniform Resource Location)
* 특정 서버의 한 리소스에 대한 구체적인 위치
* 자원의 위치와 접근 방법을 분명히 알려줌
* 예시: http://test.com/test/test.pdf 는 test.com서버에서 test폴더안의 test.pdf 파일을 요청
### (3) URN(Uniform Resource Name)
* 자원의 위치와 독립적인 이름
* URL이 변경되면 기존의 객체를 찾을 수 없다는 URL의 한계를 극복하기 위해 사용
* 예시: urn:2.19.222

## REST 
* 자원을 이름으로 구분하여 자원의 상태를 주고 받는 것
* `HTTP, WWW에서 웹에 존재하는 모든 자원에 고유한 URI를 부여`해 활용하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론
* `HTTP URI`를 통해 자원을 명시하고 `HTTP Method(POST, GET, PUT, DELETE)`를 통해 해당 자원에 대한 `CRUD` 연산을 적용

## REST API
* `REST API`는 `REST 기반의 규칙들을 지켜서 설계된 API`
* 기본 설계 원칙1. `/`를 계층관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
* 기본 설계 원칙2. 자원에 대한 정보는 명사로 표현하고 자원에 대한 `행위는 HTTP 메소드`로 표현
* 기본 설계 원칙3. 소문자와 `-(하이픈)`를 사용
* 기본 설계 원칙4. 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 둘 다 form-data 형식으로 보내든 하나로 통일

## REST API 장단점
* HTTP를 사용하므로 웹 인프라를 그대로 이용할 수 있고 MSA에 적합하여 재사용에서 이점이 존재
* HTTP를 사용하므로 HTTP 통신 모델에 제약적

## RESTful
* REST 원리를 따르는 시스템을 나타내기 위해 사용하는 용어
* RESTful한 API를 구현하는 목적은 성능 향상이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것

## HTTP GET 방식과 POST 방식의 차이
* `GET은 정보를 조회하기 위한 메소드`이고 `POST는 서버로 데이터를 전송하기 위해 설계된 메소드`
* 둘다 데이터를 서버에 전달할 수 있다는 것이 공통점이지만 GET은 `URL의 파라미터`로 이름과 데이터가 쌍으로 명시되어 전달되고, POST는 `HTTP Request Message의 Body` 부분에 데이터가 담겨있음
* GET은 `URL의 길이는 제한적이기` 때문에 많은 양의 데이터를 전송할 수 없지만 POST는 `HTTP RequestMessage의 Body`에 데이터가 담겨있어 제한이 없음

## HTTP POST 방식과 PUT 방식의 차이
* 일반적으로 POST는 생성, PUT은 수정이지만 PUT으로도 생성이 가능
* POST와 가장 큰차이는 PUT 메서드는 자원의 식별자를 이미 알고있는 상태로 POST는 request message에 포함된 엔티티를 이용해 새로운 자원을 생성해 내는 것이고, PUT은 request message와 함께 넘어온 식별자의 자원을 만드는 것
* Post: 멱등X, Put: 멱등

## HTTP 멱등성
* 같은 요청을 반복하는 경우, 모든 요청에 따른 서버의 상태가 같아야 함
* 안전한 메소드(GET, 서버의 상태 변경X)는 서버의 상태를 변경시키지 않음
* 멱등한 메소드(PUT, DELETE, GET)는 서버의 상태를 변경시킬 수도 있고 아닐 수도 있음
* POST는 멱등이 아니면서 안전하지도 않음

## 웹 브라우저에 HTTP 응답이 랜더링되는 과정 *
  *